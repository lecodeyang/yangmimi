

### 1. 了解项目的目录结构   父子工程之间的通信   依赖的版本控制 

### 2. nuxt  vue的客户端模板    template-admin后端模板   了解路由工具的封装

### 3. axios如何封装  请求方式

```js
import axios from 'axios'
import cookie from 'js-cookie'

// 创建axios实例
const service = axios.create({
  baseURL: 'http://localhost:9001',
  timeout: 15000 // 请求超时时间
  
})

// http request 拦截器
service.interceptors.request.use(
  config => {
  if (cookie.get('token')) {
    config.headers['token'] = cookie.get('token');
  }
    return config
  },
  err => {
  return Promise.reject(err);
})

export default service
```

使用 comment.js

```js
import request from '@/utils/request'

const api_name="/ucenterservice/edu-comment";

export default {

//所有分页页面显示
  getPageList(page, limit, courseId) {
    return request({
      url: `${api_name}/${page}/${limit}`,
      method: 'get',
      params: {courseId}
    })
  },
  //添加评论
  addComment(comment) {
    return request({
      url: `${api_name}/auth/save`,
      method: 'post',
      data: comment
    })
  }
}
```

> import   Api  from  'comment'

使用 Api .getPageList( page, limit, courseId); 三个参数



### 4. vuex的使用    State  Getter   Mutations  Action  Moudles

### 5. springmvc流程      

1、用户发送请求至前端控制器DispatcherServlet。

2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。

3、处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。

4、 DispatcherServlet调用HandlerAdapter处理器适配器。

5、HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。

6、Controller执行完成返回ModelAndView。

7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。

8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器。

9、ViewReslover解析后返回具体View.

10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 

11、DispatcherServlet响应用户。



### 7. Java8新特性

### 8. SpringCloud与其他分布式框架的区别  ZooKeeper  Dubbo（RPC协议）

### 9. 分布式使用那些技术    服务发现者  服务提供者   熔断器  服务请求  

### 10. 使用Dockerfile创建自己的镜像

### 11. spring security     shiro

### 12. 注册登录-------邮件方式

### 13. 注册登录-------短信方式

### 14. 单点登录集中方式(sso)  session   cookie+redis   token  使用jwt  

### 15. 集成沙箱支付宝支付   微信支付

### 16. 阿里云的OSS   OVD点播功能

### 17. SpringBoot -  EasyExcel的导入导出

### 18. springBoot - Redis的集成以及使用的场景

#### 学习分布式思想 以及相关技术  相关协议   学习shiro与security  与之间的区别



实例ID:i-wz9ieukla9l078bl5eo5
实例名称:iZwz9ieukla9l078bl5eo5Z
公网IP：47.106.171.111
内网IP：172.29.5.74



Shiro   

1. 构建自己的**Realm** 
2. 将Realm交给**SecurityManager**
3. Subject 从SecurityManager 取出来获取的对象
4. 对象取出来  realm可以做角色权限的认证  

JWT     无状态                           session是有状态的  

https://www.jianshu.com/p/576dbf44b2ae

security 

1. 继承一个接口









### 数据类的设计

#### 实体类篇

```java
package com.edu.eduservice.entity;

import java.math.BigDecimal;

import com.baomidou.mybatisplus.annotation.*;

import java.util.Date;

import java.io.Serializable;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

/**
 * <p>
 * 课程
 * </p>
 *
 * @author leCode
 * @since 2021-07-16
 */
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@ApiModel(value="EduCourse对象", description="课程")
public class EduCourse implements Serializable {

    public static final String COURSE_DRAFT = "Draft";
    public static final String COURSE_NORMAL = "Normal";
    private static final long serialVersionUID = 1L;

    @ApiModelProperty(value = "课程ID")
    @TableId(value = "id", type = IdType.ID_WORKER_STR)
    private String id;

    @ApiModelProperty(value = "课程讲师ID")
    private String teacherId;

    @ApiModelProperty(value = "课程专业ID")
    private String subjectId;

    @ApiModelProperty(value = "课程专业父级ID")
    private String subjectParentId;

    @ApiModelProperty(value = "课程标题")
    private String title;

    @ApiModelProperty(value = "课程销售价格，设置为0则可免费观看")
    private BigDecimal price;

    @ApiModelProperty(value = "总课时")
    private Integer lessonNum;

    @ApiModelProperty(value = "课程封面图片路径")
    private String cover;

    @ApiModelProperty(value = "销售数量")
    private Long buyCount;

    @ApiModelProperty(value = "浏览数量")
    private Long viewCount;

    @ApiModelProperty(value = "乐观锁")
    private Long version;

    @ApiModelProperty(value = "课程状态 Draft未发布  Normal已发布")
    private String status;

    @ApiModelProperty(value = "逻辑删除 1（true）已删除， 0（false）未删除")
    @TableLogic
    private Integer isDeleted;

    @ApiModelProperty(value = "创建时间")
    @TableField(fill = FieldFill.INSERT)
    private Date gmtCreate;

    @ApiModelProperty(value = "更新时间")
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Date gmtModified;


}

```

四个必备的字段

```java
    @ApiModelProperty(value = "逻辑删除 1（true）已删除， 0（false）未删除")
    @TableLogic
    private Integer isDeleted;

    @ApiModelProperty(value = "创建时间")
    @TableField(fill = FieldFill.INSERT)
    private Date gmtCreate;

    @ApiModelProperty(value = "更新时间")
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Date gmtModified;
```

#### 结果集篇  

返回的结果集采用统一的格式返回

```java
import io.swagger.annotations.ApiModelProperty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.HashMap;
import java.util.Map;


@Data
@AllArgsConstructor
@NoArgsConstructor
public class R {

    @ApiModelProperty(value = "是否成功")
    private Boolean success;

    @ApiModelProperty(value = "返回码")
    private Integer code;

    @ApiModelProperty(value = "返回消息")
    private String message;

    @ApiModelProperty(value = "返回数据")
    private Map<String, Object> data = new HashMap<String, Object>();

    public static R ok(){
        R r = new R();
        r.setSuccess(true);
        r.setCode(ResultCode.SUCCESS);
        r.setMessage("成功");
        return r;
    }

    public static R error(){
        R r = new R();
        r.setSuccess(false);
        r.setCode(ResultCode.ERROR);
        r.setMessage("失败");
        return r;
    }

    /**
     * @param success
     * @return 使用this从而达到连式编程
     */
    public R success(Boolean success){
        this.setSuccess(success);
        return this;
    }

    public R message(String message){
        this.setMessage(message);
        return this;
    }

    public R code(Integer code){
        this.setCode(code);
        return this;
    }


    public R data(String key,Object value){
        this.data.put(key,value);
        return this;
    }

    public R data(Map<String,Object> map){
        this.setData(map);
        return this;
    }
}
```

状态码类

```
public interface ResultCode {    public static  Integer  SUCCESS=20000;    public static  Integer  ERROR=20001;}
```

#### Query类篇

例子：  封装查询的对象  对于多个条件的查询 我们可以封装成一个对象  传入条件是就等于传入这个查询对象 ，然后我们在controller中接收对象，来判断是否传入值。

```java
@ApiModel(value = "Teacher查询对象", description = "讲师查询对象封装")@Datapublic class TeacherQuery implements Serializable {    private static final long serialVersionUID = 1L;    @ApiModelProperty(value = "教师名称,模糊查询")    private String name;    @ApiModelProperty(value = "头衔 1高级讲师 2首席讲师")    private Integer level;    @ApiModelProperty(value = "查询开始时间", example = "2019-01-01 10:10:10")    private String begin;//注意，这里使用的是String类型，前端传过来的数据无需进行类型转换    @ApiModelProperty(value = "查询结束时间", example = "2019-12-01 10:10:10")    private String end;}
```

Controller    记住**TeacherQuery  **这个对象不是必须的，如果筛选对象中的属性有值，那么就把值赋给queryWrapper对象

```java
  @PostMapping("pageTeacherCondition/{current}/{size}")    public  R pageListTeacherCondition(@PathVariable  int current, @PathVariable  int size,                              @RequestBody(required = false) TeacherQuery teacherQuery){        //创建page对象        Page<EduTeacher> pageTeacher=new Page<>(current,size);        //创建条件对象        QueryWrapper queryWrapper=new QueryWrapper();        //设置条件        String name=teacherQuery.getName();        Integer level=teacherQuery.getLevel();        String begin=teacherQuery.getBegin();        String end=teacherQuery.getEnd();        if(!StringUtils.isEmpty(name))            queryWrapper.like("name",name);        if(!StringUtils.isEmpty(level))            queryWrapper.eq("level",level);        if(!StringUtils.isEmpty(begin))            queryWrapper.ge("gmt_create",begin);        if(!StringUtils.isEmpty(end))            queryWrapper.le("gmt_create",name);        //排序        queryWrapper.orderByDesc("gmt_create");        //放入条件对象 筛选        eduTeacherService.page(pageTeacher,queryWrapper);        //总记录数        long total=pageTeacher.getTotal();        // 记录的集合        List<EduTeacher>  records=pageTeacher.getRecords();        return R.ok().data("total",total).data("records",records);    }
```

#### Vo类篇（做显示）

Vo类可以说是实体类的一个视图  返回的数据呈现给用户   并不是和表中的数据完全吻合  根据需要来选择相应的字段

>  VO:value object值对象。通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要.

形如：

```java
@Data
public class CoursePublishVo implements Serializable {
    private String title;
    private String cover;
    private Integer lessonNum;
    private String subjectLevelOne;
    private String subjectLevelTwo;
    private String teacherName;
    private String price;//只用于显示
}
```

这个类只是对Course要显示的内容进行映射

```java
//mapper自定的使用baseMapper
@Override
public CoursePublishVo getCoursePublishVoById(String id) {
    return baseMapper.selectCoursePublishVoById(id);
}
```

这里的Mapper可以需要自己联合多个表进行映射。 字段名与实体类名一一对应

```xml
  <select id="selectCoursePublishVoById" resultType="com.edu.eduservice.entity.vo.CoursePublishVo">
    SELECT
        c.title,
        c.cover,
        c.lesson_num AS lessonNum,
        CONVERT(c.price, DECIMAL(8,2)) AS price,
        s1.title AS subjectLevelOne,
        s2.title AS subjectLevelTwo,
        t.name AS teacherName
    FROM
        edu_course c
        LEFT JOIN edu_teacher t ON c.teacher_id = t.id
        LEFT JOIN edu_subject s1 ON c.subject_parent_id = s1.id
        LEFT JOIN edu_subject s2 ON c.subject_id = s2.id
    WHERE
        c.id = #{id}
</select>
```

Vo类我们一般用于查询作用。

#### Form类篇（做修改 增加 ）

一般我们在存入数据库的数据，也许一个表的数据很长，但有的数据不需要全部显示，或者在这个Form表单中显示的东西，比如或者表单一下显示两个或以上的表格中的内容，这个时候我们就需要定义一个 Form类型的类 ，专门为这个表单的修改做服务。

将courseInfoForm中属性字段与course相同的，就拷贝属性值给course对象，这样就调用 this.updateById(course);更新这个课程

> //将courseInfoForm中的数据传给course中相对应的属性
> BeanUtils.copyProperties(courseInfoForm, course);

##### 重点   前台显示的信息是，那么如果要修改应该怎么办？

实体类  这个实体类并不是根据数据库的表生成的数据库，它是根据表单的内容生成的实体类

```java
@ApiModel(value = "课程基本信息", description = "编辑课程基本信息的表单对象")@Datapublic class CourseInfoForm implements Serializable {    private static final long serialVersionUID = 1L;    @ApiModelProperty(value = "课程ID")    private String id;    @ApiModelProperty(value = "课程讲师ID")    private String teacherId;    @ApiModelProperty(value = "课程专业ID")    private String subjectId;    @ApiModelProperty(value = "课程专业父级ID")    private String subjectParentId;    @ApiModelProperty(value = "课程标题")    private String title;    @ApiModelProperty(value = "课程销售价格，设置为0则可免费观看")    //价格更为精确    private BigDecimal price;    @ApiModelProperty(value = "总课时")    private Integer lessonNum;    @ApiModelProperty(value = "课程封面图片路径")    private String cover;    @ApiModelProperty(value = "课程简介")    private String description;}
```

controller

```java
@ApiOperation(value = "更新课程")
@PutMapping("updatecourseinfo/{id}")
public R updateCourseInfoById(
        @ApiParam(name = "CourseInfoForm", value = "课程基本信息", required = true)
        @RequestBody CourseInfoForm courseInfoForm){
   eduCourseService.updateCourseInfoById(courseInfoForm);
    return R.ok();
}
```

service

```java
@Override
public void updateCourseInfoById(CourseInfoForm courseInfoForm) {
    //保存课程基本信息
    EduCourse course = new EduCourse();
    //将courseInfoForm中的数据传给course中相对应的属性
    BeanUtils.copyProperties(courseInfoForm, course);
    boolean resultCourseInfo = this.updateById(course);
    if(!resultCourseInfo){
        throw new CustomException(20001, "课程信息保存失败");
    }
    //保存课程详情信息
    EduCourseDescription courseDescription = new EduCourseDescription();
    //courseInfoForm中的描述字段  
    courseDescription.setDescription(courseInfoForm.getDescription());
    courseDescription.setId(course.getId());
    boolean resultDescription = eduCourseDescriptionService.updateById(courseDescription);
    if(!resultDescription){
        throw new CustomException(20001, "课程详情信息保存失败");
    }
}
```

#### 自定义异常篇  异常类

```java
//自定义异常类
@Data
@AllArgsConstructor  //生成带参数的构造器
@NoArgsConstructor //生成无参的构造器
public class CustomException  extends  RuntimeException{

    private Integer code;//状态码
    private  String msg;//反馈信息


}
异常类

```

```java
异常类的调用配置package com.edu.servicebase.config.ExceptionHandler;import com.edu.commonutils.R;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;@ControllerAdvice    //监测注解public class GlobalExceptionHandler {    //设置处理的异常类型    @ExceptionHandler(Exception.class)    public R error(Exception e){        e.printStackTrace();        return R.error().message("执行了全局异常处理。。。");    }    //特定异常    @ExceptionHandler(ArrayIndexOutOfBoundsException.class)    public R arrayError(ArrayIndexOutOfBoundsException e){        e.printStackTrace();        return R.error().message("数据越界异常");    }    //2. 使用自定义类    @ExceptionHandler(CustomException.class)    public R customError(CustomException e){        e.printStackTrace();        return R.error().code(e.getCode()).message(e.getMsg());    }}
```







## Mybatis-plus插件篇

持久层数据库框架mybatis-Plus 逻辑删除  分页插件 日期转换  主键生成策略  

```java
import com.baomidou.mybatisplus.core.injector.ISqlInjector;import com.baomidou.mybatisplus.extension.injector.LogicSqlInjector;import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;import com.baomidou.mybatisplus.extension.plugins.PerformanceInterceptor;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Profile;import org.springframework.transaction.annotation.EnableTransactionManagement;@Configuration@EnableTransactionManagement@MapperScan("com.edu.eduservice.mapper")   //扫描mapper类与application.yml中的文件映射public class MyBatisPlusConfig{    /**     * SQL 执行性能分析插件     * 开发环境使用，线上不推荐。 maxTime 指的是 sql 最大执行时长     */    @Bean    @Profile({"dev","test"})// 设置 dev test 环境开启    public PerformanceInterceptor performanceInterceptor() {        PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor();        //ms，超过此处设置的ms则sql不执行        performanceInterceptor.setMaxTime(1000);        performanceInterceptor.setFormat(true);        return performanceInterceptor;    }    /**     * 逻辑删除插件  在实体类上加注解        @TableLogic        private Integer isDeleted;     */    @Bean    public ISqlInjector sqlInjector(){        return new LogicSqlInjector();    }    /**     * 分页的插件     * @return     */    @Bean    public PaginationInterceptor paginationInterceptor(){        return new PaginationInterceptor();    }}
```

 直接实现该接口，发现进入该类后的entity已经重新处理updateTime了，但是更新数据库的时候，却不带updateTime更新。

#### 插入与修改的时间处理

```java
@ApiModelProperty(value = "创建时间")@TableField(fill = FieldFill.INSERT) private Date gmtCreate;@ApiModelProperty(value = "更新时间")@TableField(fill = FieldFill.INSERT_UPDATE)   //修改的时间 随着数据更新的时间而改变private Date gmtModified;
```

```java
@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler {    @Override    public void insertFill(MetaObject metaObject) {        this.setFieldValByName("gmtCreate", new Date(), metaObject);        this.setFieldValByName("gmtModified", new Date(), metaObject);    }    @Override    public void updateFill(MetaObject metaObject) {        this.setFieldValByName("gmtModified", new Date(), metaObject);    }}
```

#### 分页的实例

1. 引入mybatis的分页插件

```java
    /**     * 分页的插件     * @return     */    @Bean    public PaginationInterceptor paginationInterceptor(){        return new PaginationInterceptor();    }
```

2. 创建分页类的对象    page 当前页  limit  每页的数量

```java
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
```

```java
    @ApiOperation(value = "分页课程列表")    @GetMapping("{page}/{limit}")    public R pageQuery(            @ApiParam(name = "page", value = "当前页码", required = true)            @PathVariable Long page,            @ApiParam(name = "limit", value = "每页记录数", required = true)            @PathVariable Long limit,            @ApiParam(name = "courseQuery", value = "查询对象")                 @RequestBody(required = false)   CourseQuery courseQuery){        Page<EduCourse> pageParam = new Page<>(page, limit);        //执行pageQuery方法，将返回的对象存放到pageParam  里面有数据的集合 数据的总数量        eduCourseService.pageQuery(pageParam, courseQuery);        //pageParam.getRecords()返回的数据集合        List<EduCourse> records = pageParam.getRecords();        long total = pageParam.getTotal();        return  R.ok().data("total", total).data("rows", records);    }
```

#### 根据自己需求自定义分类，这是一个VO类，数据库并没有这个表

controller

```java
//查看自己购买的课程， 使用自定义分页@GetMapping("getMyCourseList/{current}/{size}/{userId}")public R getMyCourseList(@PathVariable  Integer current,@PathVariable Integer size,                        @PathVariable String userId) {    Page<OrderCourseVo> page = tOrderService.getOrderCourse(current, size, userId);    return R.ok().data("myOrderCourseList",page.getRecords()).data("total",page.getTotal());}
```

service

```java
@Override
public Page<OrderCourseVo> getOrderCourse(Integer current, Integer size, String userId) {
    Page<OrderCourseVo> page = new Page<>(current, size);
    if(!StringUtils.isEmpty(userId)){
        page.setRecords(baseMapper.getOrderCourse(page, userId));
    }
    return page;
}
```

mapper层根据userId筛选

```java
public List<OrderCourseVo>  getOrderCourse(Page<OrderCourseVo> page, @Param("userId") String userId);
```



## 阿里云的OSS   OVD点播功能

##### OSS 对象存储服务

1. 引入对象服务的依赖

```xml
<!--aliyunOSS-->
<dependency>
    <groupId>com.aliyun.oss</groupId>
    <artifactId>aliyun-sdk-oss</artifactId>
</dependency>
<dependency>
    <groupId>joda-time</groupId>
    <artifactId>joda-time</artifactId>
</dependency>
```



application.properties

```properties
#服务端口
server.port=8002
#服务名
spring.application.name=service-oss
# nacos服务地址
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
#环境设置：dev、test、prod
spring.profiles.active=dev
#阿里云 OSS
#不同的服务器，地址不同   分别是阿里给的地址 ID 密钥 bucket对象服务器名
aliyun.oss.file.endpoint=oss-cn-beijing.aliyuncs.com
aliyun.oss.file.keyid=LTAI5tBJEWgsq7dVN3FwxwC5
aliyun.oss.file.keysecret=ERdzYOpPkpFGlQ0XBU6O6NFElRmMuE
#bucket可以在控制台创建，也可以使用java代码创建
aliyun.oss.file.bucketname=edu-teacher-0
```

utils  读取配置文件的类

```java
import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;/*读取项目的配置 */@Componentpublic class ConstantPropertiesUtil implements InitializingBean {    @Value("${aliyun.oss.file.endpoint}")    private String endpoint;    @Value("${aliyun.oss.file.keyid}")    private String keyId;    @Value("${aliyun.oss.file.keysecret}")    private String keySecret;    @Value("${aliyun.oss.file.bucketname}")    private String bucketName;    public static String END_POINT;    public static String ACCESS_KEY_ID;    public static String ACCESS_KEY_SECRET;    public static String BUCKET_NAME;    @Override    public void afterPropertiesSet() throws Exception {        END_POINT = endpoint;        ACCESS_KEY_ID = keyId;        ACCESS_KEY_SECRET = keySecret;        BUCKET_NAME = bucketName;    }}
```

controller

```java
@ApiOperation(value = "文件上传")@PostMapping("upload")public R upload(        @ApiParam(name = "file", value = "文件", required = true)        @RequestParam("file") MultipartFile file        ) {    String uploadUrl = fileService.upload(file);    //返回r对象    return R.ok().message("文件上传成功").data("url", uploadUrl);}
```

vue上传图片的组件

```html
<!-- 课程封面--><el-form-item label="课程封面">  <el-upload    :show-file-list="false"    :on-success="handleAvatarSuccess"    :before-upload="beforeAvatarUpload"    :action="BASE_API+'eduoss/file/upload'"    class="avatar-uploader">    <img :src="courseInfo.cover">  </el-upload>        <script>  函数的回调     handleAvatarSuccess(res, file) {        console.log( res.data.url)// 上传响应        console.log(URL.createObjectURL(file.raw))// base64编码        this.courseInfo.cover = res.data.url    },    beforeAvatarUpload(file) {        const isJPG = file.type === 'image/JPG'        const isPNG = file.type === 'image/png';        const isLt2M = file.size / 1024 / 1024 < 2        if (!isJPG&&!isPNG) {            this.$message.error('上传头像图片只能是 JPG或png 格式!')        }        if (!isLt2M) {            this.$message.error('上传头像图片大小不能超过 2MB!')        }        return (isJPG || isPNG) && isLt2M        }   }   </script>
```



service 业务层的逻辑  这个方法是固定的写法。这样就返回了图片的存储路径，这里将图片的路径返回给前台的url,然后用户点击保存的时候，将这个图片的路径与对象的其他值一起存入到对象之中。

```java
import com.aliyun.oss.OSS;import com.aliyun.oss.OSSClientBuilder;import com.aliyun.oss.model.CannedAccessControlList;import com.edu.eduoss.service.FileService;import com.edu.eduoss.utils.ConstantPropertiesUtil;import com.edu.servicebase.config.ExceptionHandler.CustomException;import org.joda.time.DateTime;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;import java.io.IOException;import java.io.InputStream;import java.util.UUID;@Servicepublic class FileServiceImpl implements FileService {    @Override    public String upload(MultipartFile file) {        //获取阿里云存储相关常量        String endPoint = ConstantPropertiesUtil.END_POINT;        String accessKeyId = ConstantPropertiesUtil.ACCESS_KEY_ID;        String accessKeySecret = ConstantPropertiesUtil.ACCESS_KEY_SECRET;        String bucketName = ConstantPropertiesUtil.BUCKET_NAME;        String uploadUrl = null;        try {            //判断oss实例是否存在：如果不存在则创建，如果存在则获取            OSS ossClient = new OSSClientBuilder().build(endPoint, accessKeyId, accessKeySecret);            //如果根据以上三个参数创建一个OSS对象  如果这个实例中存在名字为bucketName的则不需要创建  否则要创建            if (!ossClient.doesBucketExist(bucketName)) {                //创建bucket                ossClient.createBucket(bucketName);                //设置oss实例的访问权限：公共读                ossClient.setBucketAcl(bucketName, CannedAccessControlList.PublicRead);            }            //获取上传文件流            InputStream inputStream = file.getInputStream();            //构建日期路径：avatar/2019/02/26/文件名            String filePath =new DateTime().toString("yyyy/MM/dd");            //文件名：uuid.扩展名            String original = file.getOriginalFilename();            String fileName = UUID.randomUUID().toString();            String fileType = original.substring(original.lastIndexOf("."));            String newName = fileName + fileType;            String fileUrl = filePath + "/" + newName;            //文件上传至阿里云            /**             * 1. bucket的名称             * 2. 文件的路径 文件的名称  aa/bb/1.png 会自己创建aa下的bb文件夹 创建1.png             * 3. 上传文件的输出流             */            ossClient.putObject(bucketName, fileUrl, inputStream);            // 关闭OSSClient。            ossClient.shutdown();            //获取url地址            uploadUrl = "http://" + bucketName + "." + endPoint + "/" + fileUrl;        } catch (IOException e) {            throw new CustomException();        }        return uploadUrl;    }}
```

至此OSS服务到这里就结束了 

当你的项目每天配置数据库，但你这个项目的分类有数据库的Jar包，这样我们在执行项目的时候，会报找不到数据库源的问题，下面这个注解就是排除数据源的配置。

> @SpringBootApplication(exclude = DataSourceAutoConfiguration.class)



##### Vod点播功能的加入

1. 同样的第一步加入依赖

```xml
<dependencies>    <dependency>        <groupId>com.aliyun</groupId>        <artifactId>aliyun-java-sdk-core</artifactId>        <version>4.3.3</version>    </dependency>    <dependency>        <groupId>com.aliyun.oss</groupId>        <artifactId>aliyun-sdk-oss</artifactId>        <version>3.1.0</version>    </dependency>    <dependency>        <groupId>com.aliyun</groupId>        <artifactId>aliyun-java-sdk-vod</artifactId>        <version>2.15.2</version>    </dependency>    <dependency>        <groupId>com.alibaba</groupId>        <artifactId>fastjson</artifactId>        <version>1.2.28</version>    </dependency>    <dependency>        <groupId>org.json</groupId>        <artifactId>json</artifactId>        <version>20170516</version>    </dependency>    <dependency>        <groupId>com.google.code.gson</groupId>        <artifactId>gson</artifactId>        <version>2.8.2</version>    </dependency>    <dependency>        <groupId>com.aliyun</groupId>        <artifactId>aliyun-sdk-vod-upload</artifactId>        <version>1.4.11</version>    </dependency></dependencies>
```

```properties
# 服务端口
server.port=8003
# 服务名
spring.application.name=service-vod
# 环境设置：dev、test、prod
spring.profiles.active=dev
#阿里云 vod
#不同的服务器，地址不同
aliyun.vod.file.keyid=LTAI5tBJEWgsq7dVN3FwxwC5
aliyun.vod.file.keysecret=ERdzYOpPkpFGlQ0XBU6O6NFElRmMuE
# 最大上传单个文件大小：默认1M
spring.servlet.multipart.max-file-size=1024MB
# 最大置总上传的数据大小 ：默认10M
spring.servlet.multipart.max-request-size=1024MB
# nacos服务地址
#spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
```

工具类  读取properties的配置

```java
//常量工具类  实现InitializingBean接口
@Component
public class ConstantPropertiesUtil implements InitializingBean {

    @Value("${aliyun.vod.file.keyid}")
    private String keyId;

    @Value("${aliyun.vod.file.keysecret}")
    private String keySecret;

    public static String ACCESS_KEY_ID;
    public static String ACCESS_KEY_SECRET;

    @Override
    public void afterPropertiesSet() throws Exception {
        ACCESS_KEY_ID = keyId;
        ACCESS_KEY_SECRET = keySecret;
    }
}
```

controller  上传视频

```java
@PostMapping("upload")
public R uploadVideo(
        @ApiParam(name = "file", value = "文件", required = true)
        @RequestParam("file") MultipartFile file) throws Exception {
    String videoId = videoService.uploadVideo(file);
    return R.ok().message("视频上传成功").data("videoId", videoId);
}
```

vue前端上传组件，

```html
<template>

  <div class="app-container">

    <h2 style="text-align: center;">发布新课程</h2>

    <el-steps :active="2" process-status="wait" align-center style="margin-bottom: 40px;">
      <el-step title="填写课程基本信息"/>
      <el-step title="创建课程大纲"/>
      <el-step title="提交审核"/>
    </el-steps>

    <el-form label-width="120px">
    <el-button type="text" @click="dialogChapterFormVisible = true">添加章节</el-button>
    <!-- 添加和修改章节表单 -->
        <el-dialog :visible.sync="dialogChapterFormVisible" title="添加章节">
            <el-form :model="chapter" label-width="120px">
                <el-form-item label="章节标题">
                    <el-input v-model="chapter.title"/>
                </el-form-item>
                <el-form-item label="章节排序">
                    <el-input-number v-model="chapter.sort" :min="0" controls-position="right"/>
                </el-form-item>
            </el-form>

            <div slot="footer" class="dialog-footer">
                <el-button @click="dialogChapterFormVisible = false">取 消</el-button>
                <el-button type="primary" @click="saveOrUpdate">确 定</el-button>
            </div>
        </el-dialog>
    <!-- 添加和修改课时表单 -->
<el-dialog :visible.sync="dialogVideoFormVisible" title="添加课时">
  <el-form :model="video" label-width="120px">
    <el-form-item label="课时标题">
      <el-input v-model="video.title"/>
    </el-form-item>
    <el-form-item label="课时排序">
      <el-input-number v-model="video.sort" :min="0" controls-position="right"/>
    </el-form-item>
    <el-form-item label="是否免费">
      <el-radio-group v-model="video.free">
        <el-radio :label="true">免费</el-radio>
        <el-radio :label="false">默认</el-radio>
      </el-radio-group>
    </el-form-item>

<el-form-item label="上传视频">
            <el-upload
                  :on-success="handleVodUploadSuccess"
                  :on-exceed="handleUploadExceed"
                  :file-list="fileList"
                  :on-remove="handleVodRemove"
                  :before-remove="beforeVodRemove"
                  :action="BASE_API+'eduvod/video/upload'"
                  :limit="1"
                  class="upload-demo">
            <el-button size="small" type="primary">上传视频</el-button>
            <el-tooltip placement="right-end">
                <div slot="content">最大支持1G，<br>
                    支持3GP、ASF、AVI、DAT、DV、FLV、F4V、<br>
                    GIF、M2T、M4V、MJ2、MJPEG、MKV、MOV、MP4、<br>
                    MPE、MPG、MPEG、MTS、OGG、QT、RM、RMVB、<br>
                    SWF、TS、VOB、WMV、WEBM 等视频格式上传</div>
                <i class="el-icon-question"/>
            </el-tooltip>
            </el-upload>
        </el-form-item>

  </el-form>
  <div slot="footer" class="dialog-footer">
    <el-button @click="dialogVideoFormVisible = false">取 消</el-button>
    <el-button :disabled="saveVideoBtnDisabled" type="primary" @click="saveOrUpdateVideo">确 定</el-button>
  </div>
</el-dialog>
        <!-- 章节 -->
        <ul class="chanpterList">
            <li
                v-for="chapter in chapterNestedList"
                :key="chapter.id">
                <p>
                    {{ chapter.title }}

                    <span class="acts">
                          <el-button type="text" @click="dialogVideoFormVisible = true; chapterId = chapter.id">添加课时</el-button>
                          <el-button type="text" @click="editChapter(chapter.id)">编辑</el-button>
                          <el-button type="text" @click="removeChapter(chapter.id)">删除</el-button>
                    </span>
                </p>

                <!-- 视频 -->

                <ul class="chanpterList videoList">
                    <li
                        v-for="video in chapter.children"
                        :key="video.id">
                        <p>{{ video.title }}
                            <span class="acts">
                                  <el-button type="text" @click="editVideo(video.id)">编辑</el-button>
                                  <el-button type="text" @click="removeVideo(video.id)">删除</el-button>
                            </span>
                        </p>
                    </li>
                </ul>
            </li>
        </ul>
        <el-button @click="previous">上一步</el-button>
        <el-button :disabled="saveBtnDisabled" type="primary" @click="next">下一步</el-button>
            </el-form>
  </div>
</template>

<script>
import chapter from '@/api/educhapter'
import video from '@/api/eduvideo'
export default {
  data() {
    return {
      saveBtnDisabled: false ,// 保存按钮是否禁用
      courseId: '', // 所属课程
      chapterNestedList: [] ,// 章节嵌套课时列表
      dialogChapterFormVisible: false, //是否显示章节表单
      fileList: [],//上传文件列表
      BASE_API: process.env.BASE_API, // 接口API地址 
      chapter: {// 章节对象
        title: '',
        sort: 0
      },
      saveVideoBtnDisabled: false, // 课时按钮是否禁用
      dialogVideoFormVisible: false, // 是否显示课时表单
      chapterId: '', // 课时所在的章节id
      video: {// 课时对象
        title: '',
        sort: 0,
        free: 0,
        videoSourceId: '',
        videoOriginalName:''
      },
    }
  },

created() {
    console.log('chapter created')
    this.init()
},

  methods: {
       previous() {
          console.log('previous')
          this.$router.push({ path: '/edu/course/save/'+ this.courseId })
        },
        init() {
        if (this.$route.params && this.$route.params.id) {
            this.courseId = this.$route.params.id
            // 根据id获取课程基本信息
            this.fetchChapterNestedListByCourseId()
          }
        },
        fetchChapterNestedListByCourseId() {
              chapter.getNestedTreeList(this.courseId).then(response => {
              this.chapterNestedList = response.data.items
              })
          },
        next() {
          this.$router.push({ path: '/edu/course/publish/' +this.courseId})
        },
        saveOrUpdate() {
            this.saveBtnDisabled = true
            if (!this.chapter.id) {
              this.saveData()
            } else {
              this.updateData()
            }
          },
        saveData() {
          this.chapter.courseId = this.courseId
          chapter.save(this.chapter).then(response => {
            this.$message({
              type: 'success',
              message: '保存成功!'
            })
            this.helpSave()
          }).catch((response) => {
            this.$message({
              type: 'error',
              message: response.message
            })
          })
        },
        //点击编辑按钮触发事件
        editChapter(chapterId) {
            this.dialogChapterFormVisible = true
            chapter.getById(chapterId).then(response => {
                this.chapter = response.data.item
            })
        },
        updateData() {
            chapter.updateById(this.chapter).then(response => {
              this.$message({
                type: 'success',
                message: '修改成功!'
              })
              this.helpSave()
            }).catch((response) => {
              this.$message({
                type: 'error',
                message: response.message
              })
            })
       },
          
      helpSave(){
        this.dialogChapterFormVisible = false// 如果保存成功则关闭对话框
        this.fetchChapterNestedListByCourseId()// 刷新列表
        this.chapter.title = ''// 重置章节标题
        this.chapter.sort = 0// 重置章节标题
        this.saveBtnDisabled = false
      },
      //删除按钮 参数就是ID  首先弹出一个确认框
      removeChapter(chapterId) {
            this.$confirm('此操作将永久删除该记录, 是否继续?', '提示', {
              confirmButtonText: '确定',
              cancelButtonText: '取消',
              type: 'warning'
            }).then(() => {
              return chapter.removeById(chapterId)
            }).then(() => {
              this.fetchChapterNestedListByCourseId()// 刷新列表
              this.$message({
                type: 'success',
                message: '删除成功!'
              })
            }).catch((response) => { // 失败
              if (response === 'cancel') {
                this.$message({
                  type: 'info',
                  message: '已取消删除'
                })
              } else {
                this.$message({
                  type: 'error',
                  message: response.message
                })
              }
            })
          },

//小章节

      saveOrUpdateVideo() {
        this.saveVideoBtnDisabled = true
        if (!this.video.id) {
          this.saveDataVideo()
        } else {
          this.updateDataVideo()
        }
      },

      saveDataVideo() {
        this.video.courseId = this.courseId
        this.video.chapterId = this.chapterId
        alert(this.video.videoSourceId)
        video.saveVideoInfo(this.video).then(response => {
          this.$message({
            type: 'success',
            message: '保存成功!'
          })
          this.helpSaveVideo()
        })
      },

      editVideo(videoId) {
        this.dialogVideoFormVisible = true
        video.getVideoInfoById(videoId).then(response => {
          this.video = response.data.item
            //新增
          this.fileList = [{'name': this.video.videoOriginalName}]
        })
      },
          updateDataVideo() {
          video.updateVideoInfoById(this.video).then(response => {
            this.$message({
              type: 'success',
              message: '修改成功!'
            })
            this.helpSaveVideo()
          })
        },

      helpSaveVideo() {
        this.dialogVideoFormVisible = false// 如果保存成功则关闭对话框
        this.fetchChapterNestedListByCourseId()// 刷新列表
        this.video.title = ''// 重置章节标题
        this.video.sort = 0// 重置章节标题
        this.video.videoSourceId = ''// 重置视频资源id
        this.saveVideoBtnDisabled = false
      },

       removeVideo(videoId) {
        this.$confirm('此操作将永久删除该记录, 是否继续?', '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          return video.removeById(videoId)
        }).then(() => {
          this.fetchChapterNestedListByCourseId()// 刷新列表
          this.$message({
            type: 'success',
            message: '删除成功!'
          })
        }).catch((response) => { // 失败
          if (response === 'cancel') {
            this.$message({
              type: 'info',
              message: '已取消删除'
            })
          }
        })
      },
            //视频成功回调
      handleVodUploadSuccess(response, file, fileList) {
        //上传成功后获得 视频的ID  传给前台
        console.log(response.data.videoId)
        this.video.videoSourceId = response.data.videoId
        //获得视频的名称
         this.video.videoOriginalName = file.name;

          this.$message.success('视频上传成功')
      },
      //视图上传多于一个视频
      handleUploadExceed(files, fileList) {

        this.$message.warning('想要重新上传视频，请先删除已上传的视频')
      },
      beforeVodRemove(file, fileList) {
          this.$confirm(`确定移除 ${file.name}？`)
      },
      handleVodRemove(file, fileList) {
        video.removeVodById(this.video.videoSourceId).then(response=>{
            //移除云端的数据之后
        this.video.videoSourceId = ''
        this.video.videoOriginalName = ''
        this.fileList = []
            this.$message({
              type: 'success',
              message: response.message
            })
          })
        },
    }
}
</script>
```

service服务层 上传视频的格式固定   同样的把视频的ID给前端，接着和前端对象一起存入到数据库 

```java
@Overridepublic String uploadVideo(MultipartFile file) {    try {        InputStream inputStream = file.getInputStream();        String originalFilename = file.getOriginalFilename();        String title = originalFilename.substring(0, originalFilename.lastIndexOf("."));        UploadStreamRequest request = new UploadStreamRequest(                ConstantPropertiesUtil.ACCESS_KEY_ID,                ConstantPropertiesUtil.ACCESS_KEY_SECRET,                title, originalFilename, inputStream);        UploadVideoImpl uploader = new UploadVideoImpl();        UploadStreamResponse response = uploader.uploadStream(request);        //如果设置回调URL无效，不影响视频上传，可以返回VideoId同时会返回错误码。        // 其他情况上传失败时，VideoId为空，此时需要根据返回错误码分析具体错误原因        String videoId = response.getVideoId();        if (!response.isSuccess()) {            String errorMessage = "阿里云上传错误：" + "code：" + response.getCode() + ", message：" + response.getMessage();           // log.warn(errorMessage);            if(StringUtils.isEmpty(videoId)){                throw new CustomException(20001, errorMessage);            }        }        return videoId;    } catch (IOException e) {        throw new CustomException(20001, " vod 服务上传失败");    }}
```

视频的点播功能，前端传来videoId 根据ID取得相应的播放凭证可以播放，前端接收凭证

```java
@GetMapping("get-play-auth/{videoId}")public R getVideoPlayAuth(@PathVariable("videoId") String videoId) throws Exception {    //获取阿里云存储相关常量    String accessKeyId = ConstantPropertiesUtil.ACCESS_KEY_ID;    String accessKeySecret = ConstantPropertiesUtil.ACCESS_KEY_SECRET;    //初始化    DefaultAcsClient client = AliyunVodSDKUtils.initVodClient(accessKeyId, accessKeySecret);    //请求    GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest();    request.setVideoId(videoId);    //响应    GetVideoPlayAuthResponse response = client.getAcsResponse(request);    //得到播放凭证    String playAuth = response.getPlayAuth();    System.out.print(playAuth);    //返回结果    return R.ok().message("获取凭证成功").data("playAuth", playAuth);}
```







## 支付宝接口调用

引入pom.xml的配置文件

```xml
<dependencies>        <dependency>            <groupId>org.springframework.boot</groupId>            <artifactId>spring-boot-starter-web</artifactId>        </dependency>        <dependency>            <groupId>org.springframework.boot</groupId>            <artifactId>spring-boot-starter-thymeleaf</artifactId>        </dependency>        <dependency>            <groupId>org.projectlombok</groupId>            <artifactId>lombok</artifactId>            <optional>true</optional>        </dependency>        <dependency>            <groupId>org.apache.commons</groupId>            <artifactId>commons-lang3</artifactId>            <version>3.8</version>        </dependency>        <!-- 阿里沙箱环境 -->        <dependency>            <groupId>com.alipay.sdk</groupId>            <artifactId>alipay-sdk-java</artifactId>            <version>4.9.28.ALL</version>        </dependency>    </dependencies>
```

登录阿里云沙箱支付的

根据阿里云给出的文档，下载微信支付开放助手，替换公钥，在application.properties配置

```properties
# Thymeleaf的配置spring.thymeleaf.cache=falsespring.thymeleaf.mode=HTML5spring.thymeleaf.encoding=UTF-8# 在支付宝创建的应用IDpay.alibaba.appid=# 商户私钥pay.alibaba.merchantPrivateKeypay.alibaba.merchantPrivateKey= # 支付宝公钥  pay.alibaba.alipayPublicKey   pay.alibaba.alipayPublicKey - 查看地址： https://openhome.alipay.com/platform/keyManage.htm 对应APPID下的支付宝公钥pay.alibaba.alipayPublicKey=# 支付宝会悄悄的给我们发送一个请求，告诉我们支付成功的信息  自己定义的一个 payed/notify 异步请求pay.alibaba.notifyUrl=http://www.eafee.com/payed/notify    #异步的调用注意路径# 同步通知，支付成功，一般跳转到成功页pay.alibaba.returnUrl=http://localhost:8080/success.html   # 支付成功跳转到的接口# 签名方式pay.alibaba.signType=RSA2# 字符编码格式pay.alibaba.charset=utf-8# 订单失效时间 - 30分钟pay.alibaba.timeout=30m# 支付宝网关； https://openapi.alipaydev.com/gateway.dopay.alibaba.gatewayUrl=https://openapi.alipaydev.com/gateway.do
```

创建一个类读取配置文件中的内容

```java
package per.liuchengyin.alipay.config;

import com.alipay.api.AlipayApiException;
import com.alipay.api.AlipayClient;
import com.alipay.api.DefaultAlipayClient;
import com.alipay.api.request.AlipayTradePagePayRequest;
import lombok.Data;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import per.liuchengyin.alipay.pojo.PayVo;

/**
 * @ClassName AliPayTemplate
 * @Description 根据支付宝官方Demo提取出来的Template，旧版SDK
 * 旧版Demo下载地址： https://opendocs.alipay.com/open/270/106291
 * @Author gaofee
 * @Date 2021/3/23
 */
@Component
@Data
public class AliPayTemplate {
    /** 在支付宝创建的应用ID */
    @Value("${pay.alibaba.appid}")
    private String appId;
    /** 商户私钥 */
    @Value("${pay.alibaba.merchantPrivateKey}")
    private String merchantPrivateKey;
    /** 支付宝公钥 - 查看地址： https://openhome.alipay.com/platform/keyManage.htm 对应APPID下的支付宝公钥 */
    @Value("${pay.alibaba.alipayPublicKey}")
    private  String alipayPublicKey;
    // 服务器[异步通知]页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
    /**  支付宝会悄悄的给我们发送一个请求，告诉我们支付成功的信息 */
    @Value("${pay.alibaba.notifyUrl}")
    private  String notifyUrl;
    // 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
    /** 同步通知，支付成功，一般跳转到成功页 */
    @Value("${pay.alibaba.returnUrl}")
    private  String returnUrl;
    /** 签名方式 */
    @Value("${pay.alibaba.signType}")
    private  String signType;
    /** 字符编码格式 */
    @Value("${pay.alibaba.charset}")
    private  String charset;
    /** 订单失效时间 - 30分钟 */
    @Value("${pay.alibaba.timeout}")
    private String timeout;
    /** 支付宝网关； https://openapi.alipaydev.com/gateway.do */
    @Value("${pay.alibaba.gatewayUrl}")
    private  String gatewayUrl;

    /**
     * 支付
     * @param vo 支付信息
     * @return 响应页面
     * @throws AlipayApiException
     */
    //调用支付宝信息  取到的订单   付款
    public String pay(PayVo vo) throws AlipayApiException {
        /**
        1、根据支付宝的配置生成一个支付客户端
        这句话主要是初始化一个DefaultAlipayClient，这个类的初始化构造器需要传很多参数，从左往右依次为：支付宝的网关，商户的appid,商户的私钥，传参的格式，传参的字符集，商户的公钥，商户的签名类型。这里都把这些参数封装进了AlipayConfig这个类里面，来看看AlipayConfig这个类：
        */
        AlipayClient alipayClient = new DefaultAlipayClient(gatewayUrl,
                appId, merchantPrivateKey, "json",
                charset, alipayPublicKey, signType);
        // 2、创建一个支付请求 - 设置请求参数
        AlipayTradePagePayRequest aliPayRequest = new AlipayTradePagePayRequest();
        aliPayRequest.setReturnUrl(returnUrl);
        aliPayRequest.setNotifyUrl(notifyUrl);
        // 商户订单号，商户网站订单系统中唯一订单号，必填
        String out_trade_no = vo.getOutTradeNo();
        // 付款金额，必填
        String total_amount = vo.getTotalAmount();
        // 订单名称，必填
        String subject = vo.getSubject();
        // 商品描述，可空
        String body = vo.getBody();
        aliPayRequest.setBizContent("{\"out_trade_no\":\""+ out_trade_no +"\","
                + "\"total_amount\":\""+ total_amount +"\","
                + "\"subject\":\""+ subject +"\","
                + "\"body\":\""+ body +"\","
                + "\"timeout_express\":\""+timeout+"\","
                + "\"product_code\":\"FAST_INSTANT_TRADE_PAY\"}");

        // 会收到支付宝的响应，响应的是一个页面，只要浏览器显示这个页面，就会自动来到支付宝的收银台页面
        return alipayClient.pageExecute(aliPayRequest).getBody();
    }
}

```

1. 第一步显示支付的页面，商品的对象目前是模拟的状态，直接在后台赋值

```html
<body>    <h1>初始页面</h1>    <!-- 订单号在这里是固定了，其实后端方便测试做了一个雪花算法的id -->    <a href="http://localhost:8080/payOrder?orderSn=123456">支付宝 - 立即支付</a></body>
```

2. 点击立即支付，执行controller中的这个方法orderSn在后端会自己生成

```java
@Controller
@Slf4j
public class PayWebController {
    @Autowired
    private AliPayTemplate aliPayTemplate;
    @Autowired
    private OrderService orderService;

    /**
     * 调用该方法会去到支付宝支付
     * @param orderSn 订单号
     * @return 返回的是支付宝的页面 - produces = "text/html"
     * @throws AlipayApiException 支付异常
     */
    @GetMapping(value = "/payOrder", produces = "text/html")
    @ResponseBody
    public String payOrder(@RequestParam("orderSn") String orderSn) throws AlipayApiException {
        // 这里订单号应该是前端传过来的，即orderSn
        // 但是为了Demo方便测试，前端传来的是一个固定的数字(按理说前端应该传的是具体订单号)
        // 支付宝这个订单号又不能重复，所以在这个方法里实际使用了一个雪花算法生成的订单号，即noStr
        String noStr = SnowflakeIdWorker.generateId() + "";
        //雪花算法
        log.info("订单ID：{}", noStr);
        // 正常的应该是传入前端传来的orderSn
        PayVo payVo = orderService.getOrderPay(noStr);
        return aliPayTemplate.pay(payVo);
    }

}
```

3. 去service层根据这个订单号找到相应的商品，找到之后返回给AliPayTemplate类的支付方法

```java
//返回一个订单信息
@Override
public PayVo getOrderPay(String orderSn) {
    // 模拟一个订单
    PayVo payVo = new PayVo();
    // 订单号
    payVo.setOutTradeNo(orderSn);
    payVo.setSubject("测试商品");
    payVo.setBody("这是测试支付宝沙箱环境专用的测试商品！");
    payVo.setTotalAmount("0.01");
    return payVo;
}
```

4. 调用AliPayTemplate的支付方法，然后你就会跳转到支付宝的支付页面了

```java
public String pay(PayVo vo) throws AlipayApiException {
    // 1、根据支付宝的配置生成一个支付客户端
    AlipayClient alipayClient = new DefaultAlipayClient(gatewayUrl,
            appId, merchantPrivateKey, "json",
            charset, alipayPublicKey, signType);
    // 2、创建一个支付请求 - 设置请求参数
    AlipayTradePagePayRequest aliPayRequest = new AlipayTradePagePayRequest();
    aliPayRequest.setReturnUrl(returnUrl);
    aliPayRequest.setNotifyUrl(notifyUrl);
    // 商户订单号，商户网站订单系统中唯一订单号，必填
    String out_trade_no = vo.getOutTradeNo();
    // 付款金额，必填
    String total_amount = vo.getTotalAmount();
    // 订单名称，必填
    String subject = vo.getSubject();
    // 商品描述，可空
    String body = vo.getBody();
    aliPayRequest.setBizContent("{\"out_trade_no\":\""+ out_trade_no +"\","
            + "\"total_amount\":\""+ total_amount +"\","
            + "\"subject\":\""+ subject +"\","
            + "\"body\":\""+ body +"\","
            + "\"timeout_express\":\""+timeout+"\","
            + "\"product_code\":\"FAST_INSTANT_TRADE_PAY\"}");

    // 会收到支付宝的响应，响应的是一个页面，只要浏览器显示这个页面，就会自动来到支付宝的收银台页面
    return alipayClient.pageExecute(aliPayRequest).getBody();
}
```

退款

```java
 /**
     * 支付宝退款接口
     * @param outTradeNo
     * @param tradeNo
     * @param refundAmount
     * @param refundReason
     * @param out_request_no  标识一次退款请求，同一笔交易多次退款需要保证唯一，如需部分退款，则此参数必传
     * @return
     */
    public static String aliRefund(String outTradeNo,String tradeNo,String refundAmount,String refundReason,String out_request_no) {
        //获得初始化的AlipayClient
                AlipayClient alipayClient = new DefaultAlipayClient(AlipayConfig.gatewayUrl, AlipayConfig.app_id, AlipayConfig.merchant_private_key, "json", AlipayConfig.charset, AlipayConfig.alipay_public_key, AlipayConfig.sign_type);
                //设置请求参数
                AlipayTradeRefundRequest alipayRequest = new AlipayTradeRefundRequest();
                alipayRequest.setReturnUrl(AlipayConfig.return_url);
                alipayRequest.setNotifyUrl(AlipayConfig.notify_url);
                try {               
                    alipayRequest.setBizContent("{\"out_trade_no\":\""+ outTradeNo +"\"," 
                            + "\"trade_no\":\""+ tradeNo +"\"," 
                            + "\"refund_amount\":\""+ refundAmount +"\"," 
                            + "\"refund_reason\":\""+ refundReason +"\"," 
                            + "\"out_request_no\":\""+ out_request_no +"\"}");                           
                //请求
                String result;
                //请求
                result = alipayClient.execute(alipayRequest).getBody();
                System.out.println("*********************\n返回结果为："+result);
                return result;
                } catch (Exception e) {
                    e.printStackTrace();
                    return null;
                }
    }
```

5. 支付成功时候会执行异步回调接口验证支付 ，校验签名是否正确 这个接口我们在  配置文件中配置了

   >  pay.alibaba.notifyUrl=http://www.eafee.com/payed/notify      内网穿透  *必须外网可以正常访问*

```java
package per.liuchengyin.alipay.controller;

import com.alipay.api.AlipayApiException;
import com.alipay.api.internal.util.AlipaySignature;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;
import per.liuchengyin.alipay.config.AliPayTemplate;
import per.liuchengyin.alipay.pojo.PayAsyncVo;
import per.liuchengyin.alipay.service.OrderService;

import javax.servlet.http.HttpServletRequest;
import java.io.UnsupportedEncodingException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * @ClassName OrderPayedListener
 * @Description 支付宝异步回调Controller - 监听器
 */
@RestController
@Slf4j
public class OrderPayedListener {
    @Autowired
    private OrderService orderService;

    @Autowired
    private AliPayTemplate alipayTemplate;

    /**
     * 异步结果通知回调方法
     * @param vo 支付宝异步通知返回的结果
     * @param request request
     * @return 是否验签通过
     * @throws UnsupportedEncodingException
     * @throws AlipayApiException
     */
    @PostMapping("/payed/notify")
    public String handleAlipayed(PayAsyncVo vo, HttpServletRequest request) throws UnsupportedEncodingException, AlipayApiException {
        // 验证签名
        boolean signVerified = checkV1(request);
        if(signVerified){
            // 签名验证通过
            log.info("签名验证成功！");
            // 处理支付结果
            // 只要收到了支付宝给我们异步的通知，告诉我们订单支付成功，返回success，支付宝就不会再通知
            return orderService.handlePayResult(vo);
        }else{
            // 只要回复的不是success，就会一直通知
            log.info("签名验证失败！");
            return "error";
        }
    }

    /**
     * 校验签名
     * @param request request
     * @return 是否验证通过
     * @throws AlipayApiException 支付异常
     */
    private boolean checkV1(HttpServletRequest request) throws AlipayApiException {
        /*
         * 支付宝验证签名
         * 获取支付宝POST过来反馈信息
         */
        Map<String, String> params = new HashMap<String, String>();
        Map<String, String[]> requestParams = request.getParameterMap();
        for (Iterator<String> iter = requestParams.keySet().iterator(); iter.hasNext(); ) {
            String name = (String) iter.next();
            String[] values = (String[]) requestParams.get(name);
            String valueStr = "";
            for (int i = 0; i < values.length; i++) {
                valueStr = (i == values.length - 1) ? valueStr + values[i]
                        : valueStr + values[i] + ",";
            }
            // 乱码解决，这段代码在出现乱码时使用
            // valueStr = new String(valueStr.getBytes("ISO-8859-1"), "utf-8");
            params.put(name, valueStr);
        }
         //重点！！！！！！！！！！！！！！！  签名成功
        params.remove("sign_type");  
        
        // 调用SDK验证签名
        return AlipaySignature.rsaCheckV1(params, alipayTemplate.getAlipayPublicKey(), alipayTemplate.getCharset(), alipayTemplate.getSignType());
    }
}
```

6. 签名正确了就可以对数据库操作    就执行同步回调，跳转到页面 成功页面

接着异步方法中方法的调用   , 在这里可以进行数据的主力

将返回参数封装在实体bean中，这样springmvc会利用反射机制自动将相关参数映射进实体bean里面，省去了我们自己再去解析参数的麻烦。后面那句returnPay.getTrade_status().equals(“TRADE_SUCCESS”)是得到支付宝中trade_status这个参数，在支付宝的接口文档中，若这个参数等于TRADE_SUCCESS，则说明支付是成功的，然后我就会调用tbPaymentRecordsService.aliPaySuccess(returnPay);。

> return orderService.handlePayResult(vo);

```java
@Override
public String handlePayResult(PayAsyncVo vo) {
    // 可以将vo里的相关支付信息保存到数据库....
    // 判断是否支付成功 - 获取状态，只有以下两种状态是支付成功了
    if (TransactionStatus.TRADE_SUCCESS.equals(vo.getTrade_status()) || TransactionStatus.TRADE_FINISHED.equals(vo.getTrade_status())) {
        // 支付成功状态 - 可以根据订单号修改数据库里订单状态为已支付....
        String outTradeNo = vo.getOut_trade_no();
    }
    return "success";
}
```

状态类

```,.。java
/**
 * @ClassName TransactionStatus
 * @Description 交易状态(决定是否触发异步通知) - 支付宝官方文档：https://opendocs.alipay.com/open/270/105902
 * @Author gaofee
 * @Date 2021/3/24
 */
public interface TransactionStatus {
    /**
     * 触发通知的条件
     * TRADE_FINISHED - false（不触发通知）
     * TRADE_SUCCESS - true（触发通知）
     * WAIT_BUYER_PAY - false（不触发通知）
     * TRADE_CLOSED - false（不触发通知）
     */
    /** 交易创建，等待买家付款 */
    String WAIT_BUYER_PAY = "WAIT_BUYER_PAY";
    /** 未付款交易超时关闭，或支付完成后全额退款 */
    String TRADE_CLOSED = "TRADE_CLOSED";
    /** 交易支付成功 */
    String TRADE_SUCCESS = "TRADE_SUCCESS";
    /** 交易结束，不可退款 */
    String TRADE_FINISHED = "TRADE_FINISHED";


}

```

![](img/目录结构.png)

## SpringBoot -  EasyExcel的导入导出

1. 导入依赖

```xml
<dependencies>    <!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel -->    <dependency>        <groupId>com.alibaba</groupId>        <artifactId>easyexcel</artifactId>        <version>2.1.1</version>    </dependency></dependencies>
```

2. 前端vue的样式

```html
<div class="app-container">    <el-form label-width="120px">      <el-form-item label="信息描述">        <el-tag type="info">excel模版说明</el-tag>        <el-tag>          <i class="el-icon-download"/>          <a :href="OSS_PATH + '/subject.xlsx'">点击下载模版</a>        </el-tag>      </el-form-item>      <el-form-item label="选择Excel">        <el-upload          ref="upload"          :auto-upload="false"          :on-success="fileUploadSuccess"          :on-error="fileUploadError"          :disabled="importBtnDisabled"          :limit="1"          :action="BASE_API+'/eduservice/edusubject/addSubject'"          name="file"          >          <!--accept="application/vnd.ms-excel"-->          <el-button slot="trigger" size="small" type="primary">选取文件</el-button>          <el-button            :loading="loading"            style="margin-left: 10px;"            size="small"            type="success"            @click="submitUpload">加入数据库</el-button>        </el-upload>      </el-form-item>    </el-form>  </div>
```

```js
  data() {    return {      BASE_API: process.env.BASE_API, // 接口API地址      EXCEL_OSS_PATH: process.env.OSS_PATH, // 阿里云OSS地址      importBtnDisabled: false, // 按钮是否禁用,      loading: false    }  },  methods: {            submitUpload() {            this.fileUploadBtnText = '正在上传'            this.importBtnDisabled = true            this.loading = true            //refs取结点  所以应该是 document.getElementById("upload")            this.$refs.upload.submit()            },        fileUploadSuccess(response) {            if (response.success === true) {            this.fileUploadBtnText = '导入成功'            this.loading = false            this.$message({                type: 'success',                message: response.message            })            }         },        fileUploadError(response) {            this.fileUploadBtnText = '导入失败'            this.loading = false            this.$message({            type: 'error',            message: '导入失败'            })        }}}
```

2. controller层

```java
@PostMapping("/addSubject")public R saveSubject(MultipartFile file) {    eduSubjectService.saveSubject(file, eduSubjectService);    return R.ok();}
```

```java
@Overridepublic void saveSubject(MultipartFile multipartFile, EduSubjectService subjectService) {    try {        //1 获取文件输入流        InputStream inputStream = multipartFile.getInputStream();        // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭        EasyExcel.read(inputStream, ExcelSubjectData.class, new SubjectExcelListener(subjectService)).sheet().doRead();    } catch (Exception e) {        e.printStackTrace();        throw new CustomException(20002, "添加课程分类失败");    }}
```

这里面最主要的就是一个监听类

```java
package com.edu.eduservice.config;

import com.alibaba.excel.context.AnalysisContext;
import com.alibaba.excel.event.AnalysisEventListener;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.edu.eduservice.entity.EduSubject;
import com.edu.eduservice.entity.excel.ExcelSubjectData;
import com.edu.eduservice.service.EduSubjectService;
import com.edu.servicebase.config.ExceptionHandler.CustomException;

import java.util.Map;

public class SubjectExcelListener extends AnalysisEventListener<ExcelSubjectData> {

    public EduSubjectService subjectService;

    public SubjectExcelListener() {
    }

    //创建有参数构造，传递subjectService用于操作数据库
    public SubjectExcelListener(EduSubjectService subjectService) {
        this.subjectService = subjectService;
    }

    //一行一行去读取excel内容
    @Override
    public void invoke(ExcelSubjectData data, AnalysisContext analysisContext) {
        if (data == null) {
            throw new CustomException(20001, "添加失败");
        }
        //添加一级分类
        EduSubject existOneSubject = this.existOneSubject(subjectService, data.getOneSubjectName());
        if (existOneSubject == null) {//没有相同的
            existOneSubject = new EduSubject();
            existOneSubject.setTitle(data.getOneSubjectName());
            existOneSubject.setParentId("0");
            subjectService.save(existOneSubject);
        }

        //获取一级分类id值
        String pid = existOneSubject.getId();

        //添加二级分类
        EduSubject existTwoSubject = this.existTwoSubject(subjectService, data.getTwoSubjectName(), pid);
        if (existTwoSubject == null) {
            existTwoSubject = new EduSubject();
            existTwoSubject.setTitle(data.getTwoSubjectName());
            existTwoSubject.setParentId(pid);
            subjectService.save(existTwoSubject);
        }
    }

    //读取excel表头信息
    @Override
    public void invokeHeadMap(Map<Integer, String> headMap, AnalysisContext context) {
        System.out.println("表头信息：" + headMap);
    }

    //读取完成后执行
    @Override
    public void doAfterAllAnalysed(AnalysisContext analysisContext) {
    }

    //判断一级分类是否重复
    private EduSubject existTwoSubject(EduSubjectService subjectService, String name, String pid) {
        QueryWrapper<EduSubject> wrapper = new QueryWrapper<>();
        wrapper.eq("title", name);
        wrapper.eq("parent_id", pid);
        EduSubject eduSubject = subjectService.getOne(wrapper);
        return eduSubject;
    }

    //判断一级分类是否重复
    private EduSubject existOneSubject(EduSubjectService subjectService, String name) {
        QueryWrapper<EduSubject> wrapper = new QueryWrapper<>();
        wrapper.eq("title", name);
        wrapper.eq("parent_id", "0");
        EduSubject eduSubject = subjectService.getOne(wrapper);
        return eduSubject;
    }
}
```

这个方法就可以把excel中的数据取到，存入到数据库。

## 邮箱注册 登录功能

1. 导入依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
```

2. controller 首先判断redis中是否存在该邮箱获得验证码， 如果没有就向后端发送一个请求，把邮箱验证码发出去。

```java
import com.edu.commonutils.R;
import com.edu.mailservice.service.MailService;
import com.edu.mailservice.utils.RandomUtil;
import net.bytebuddy.asm.Advice;
import org.junit.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.TimeoutUtils;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.concurrent.TimeUnit;

@RestController
@RequestMapping("/mailservice")
public class MainController {
    @Autowired
    private MailService mailService;

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    @GetMapping("/send_email/{tomail}")
    public R test(@PathVariable("tomail") String tomail) {
        //redis取不到
        String main_code = redisTemplate.opsForValue().get(tomail);
        if (!StringUtils.isEmpty(main_code)) {
            return R.ok();
        }
        //code就短信发送
        main_code = RandomUtil.getFourBitRandom();
        boolean flag = mailService.sendSimpleMail(tomail, main_code);
        if (flag) {
            //key value 时间  时间的单位
            redisTemplate.opsForValue().set(tomail, main_code, 5, TimeUnit.MINUTES);
            return R.ok();
        } else {
            return R.error().message("邮件发送失败");
        }

    }

}
```

```java
package com.edu.mailservice.service.Imp;

import com.edu.mailservice.service.MailService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

@Service
public class MailServiceImp implements MailService {

    @Value("${spring.mail.username}")
    private String from;

    @Autowired
    JavaMailSender javaMailSender;

    public boolean sendSimpleMail(String tomail, String main_code) {
        if (StringUtils.isEmpty(tomail)) {
            return false;
        } else {
            SimpleMailMessage simpleMailMessage = new SimpleMailMessage();
            simpleMailMessage.setFrom(from);
            simpleMailMessage.setTo(tomail);
            simpleMailMessage.setSubject("在线教育平台");
            String content = "在线教育平台提供的验证码为----" + main_code + "---请在5分钟之内有效";
            simpleMailMessage.setText(content);
            javaMailSender.send(simpleMailMessage);
            return true;
        }
    }

}
```

随机字符串的产生，工具类

```java
import java.text.DecimalFormat;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Random;/** * 获取随机数 * * @author qianyi */public class RandomUtil {    private static final Random random = new Random();    private static final DecimalFormat fourdf = new DecimalFormat("0000");    private static final DecimalFormat sixdf = new DecimalFormat("000000");    public static String getFourBitRandom() {        return fourdf.format(random.nextInt(10000));    }    public static String getSixBitRandom() {        return sixdf.format(random.nextInt(1000000));    }    /**     * 给定数组，抽取n个数据     *     * @param list     * @param n     * @return     */    public static ArrayList getRandom(List list, int n) {        Random random = new Random();        HashMap<Object, Object> hashMap = new HashMap<Object, Object>();        // 生成随机数字并存入HashMap        for (int i = 0; i < list.size(); i++) {            int number = random.nextInt(100) + 1;            hashMap.put(number, i);        }        // 从HashMap导入数组        Object[] robjs = hashMap.values().toArray();        ArrayList r = new ArrayList();        // 遍历数组并打印数据        for (int i = 0; i < n; i++) {            r.add(list.get((int) robjs[i]));            System.out.print(list.get((int) robjs[i]) + "\t");        }        System.out.print("\n");        return r;    }}
```

配置文件

```properties
# 服务端口
server.port=8005
# 服务名
spring.application.name=service-mail
#邮箱服务器地址，各大运营商不同 QQ邮箱的发送
spring.mail.host=smtp.qq.com
#用户名
spring.mail.username=318667376@qq.com
#密码，如果是qq的，要申请临时授权码
spring.mail.password=fewopnneysisbiae
spring.mail.default-encoding=UTF-8
#以谁来发送邮件
mail.fromMail.addr=318667376@qq.com
spring.redis.host=47.106.171.111
spring.redis.port=6379
#Redis服务器连接密码（默认为空）
spring.redis.password=mypass
spring.redis.database=0
spring.redis.timeout=30000
spring.redis.lettuce.pool.max-active=20
spring.redis.lettuce.pool.max-wait=-1
#最大阻塞等待时间(负数表示没限制)
spring.redis.lettuce.pool.max-idle=5
spring.redis.lettuce.pool.min-idle=0
#返回json的全局时间格式
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8
#注册服务
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
```

以上都是邮箱辅助 生成验证码

下面是登录流程

```java
package com.edu.ucenterservice.controller;


import com.edu.commonutils.JwtUtils;
import com.edu.commonutils.R;
import com.edu.servicebase.config.ExceptionHandler.CustomException;
import com.edu.ucenterservice.entity.UcenterMember;
import com.edu.commonutils.vo.CommentVo;
import com.edu.ucenterservice.entity.vo.LoginVo;
import com.edu.ucenterservice.entity.vo.RegisterVo;
import com.edu.ucenterservice.service.UcenterMemberService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;

/**
 * <p>
 * 会员表 前端控制器
 * </p>
 *
 * @author leCode
 * @since 2021-07-26
 */
@RestController
@RequestMapping("/ucenterservice/ucenter-member")
public class UcenterMemberController {

    @Autowired
    private UcenterMemberService ucenterMemberService;

    @ApiOperation(value = "会员登录")
    @PostMapping("login")
    public R login(@RequestBody LoginVo loginVo) {
        String token = ucenterMemberService.login(loginVo);
        return R.ok().data("token", token);
    }

    @ApiOperation(value = "会员注册")
    @PostMapping("register")
    public R register(@RequestBody RegisterVo registerVo) {
        ucenterMemberService.register(registerVo);
        return R.ok();
    }

    @ApiOperation(value = "根据token获取登录信息")
    @GetMapping("getLoginInfo")
    public R getLoginInfo(HttpServletRequest request) {
        try {
            String memberId = JwtUtils.getMemberIdByJwtToken(request);
            UcenterMember ucenterMember = ucenterMemberService.getLoginInfo(memberId);
            return R.ok().data("userInfo", ucenterMember);
        } catch (Exception e) {
            e.printStackTrace();
            throw new CustomException(20001, "error");
        }
    }

    //根据token字符串获取用户信息,评论模块
    @PostMapping("getInfoUc/{id}")
    public CommentVo getInfo(@PathVariable String id) {
        //根据用户id获取用户信息
        UcenterMember ucenterMember = ucenterMemberService.getById(id);
        CommentVo memeber = new CommentVo();
        BeanUtils.copyProperties(ucenterMember, memeber);
        return memeber;
    }

    //根据token字符串获取用户信息
    @PostMapping("getInfoAll/{id}")
    public UcenterMember getAllInfo(@PathVariable String id) {
        //根据用户id获取用户信息
        UcenterMember ucenterMember = ucenterMemberService.getById(id);
        return ucenterMember;
    }
}
```





```java
package com.edu.ucenterservice.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.edu.commonutils.JwtUtils;
import com.edu.servicebase.config.ExceptionHandler.CustomException;
import com.edu.ucenterservice.entity.UcenterMember;
import com.edu.ucenterservice.entity.vo.LoginVo;
import com.edu.ucenterservice.entity.vo.RegisterVo;
import com.edu.ucenterservice.mapper.UcenterMemberMapper;
import com.edu.ucenterservice.service.UcenterMemberService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.edu.commonutils.MD5;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

/**
 * <p>
 * 会员表 服务实现类
 * </p>
 *
 * @author leCode
 * @since 2021-07-26
 */
@Service
public class UcenterMemberServiceImpl extends ServiceImpl<UcenterMemberMapper, UcenterMember> implements UcenterMemberService {
    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    /**
     * 会员登录
     * 返回一个token值 前端接受这个token值，每次请求获取用户信息都需要携带这个token
     * @param loginVo
     * @return
     */
    @Override
    public String login(LoginVo loginVo) {
        String email = loginVo.getEmail();
        String password = loginVo.getPassword();

        //校验参数
        if (StringUtils.isEmpty(email) ||
                StringUtils.isEmpty(password) ||
                StringUtils.isEmpty(email)) {
            throw new CustomException(20001, "error");
        }

        //获取会员
        UcenterMember member = baseMapper.selectOne(new QueryWrapper<UcenterMember>().eq("email", email));
        if (null == member) {
            throw new CustomException(20001, "error");
        }

        //校验密码  使用MD5对用户的密码进行校验  
        if (!MD5.encrypt(password).equals(member.getPassword())) {
            throw new CustomException(20001, "error");
        }

        //校验是否被禁用
        if (member.getIsDisabled()) {
            throw new CustomException(20001, "error");
        }

        //使用JWT生成token字符串
        String token = JwtUtils.getJwtToken(member.getId(), member.getNickname());
        return token;
    }

    /**
     * 会员注册
     *
     * @param registerVo
     */
    @Override
    public void register(RegisterVo registerVo) {
        //获取注册信息，进行校验
        String nickname = registerVo.getNickname();
        String email = registerVo.getEmail();
        String password = registerVo.getPassword();
        String code = registerVo.getCode();

        //校验参数
        if (StringUtils.isEmpty(email) ||
                StringUtils.isEmpty(email) ||
                StringUtils.isEmpty(password) ||
                StringUtils.isEmpty(code)) {
            throw new CustomException(20001, "error");
        }
        //校验校验验证码
        //从redis获取发送的验证码
        String mobleCode = redisTemplate.opsForValue().get(email);
        System.out.print(mobleCode);
        if (!code.equals(mobleCode)) {
            throw new CustomException(20001, "error");
        }
        //查询数据库中是否存在相同的手机号码
        Integer count = baseMapper.selectCount(new QueryWrapper<UcenterMember>().eq("email", email));
        if (count.intValue() > 0) {
            throw new CustomException(20001, "error");
        }
        //添加注册信息到数据库
        UcenterMember member = new UcenterMember();
        member.setNickname(nickname);
        member.setEmail(registerVo.getEmail());
        //密码采用MD5加密
        member.setPassword(MD5.encrypt(password));
        member.setIsDisabled(false);
        //设置一个默认头像
        member.setAvatar("http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoj0hHXhgJNOTSOFsS4uZs8x1ConecaVOB8eIl115xmJZcT4oCicvia7wMEufibKtTLqiaJeanU2Lpg3w/132");
        this.save(member);
    }

    @Override
    public UcenterMember getLoginInfo(String memberId) {
        UcenterMember member = baseMapper.selectById(memberId);
        return member;
    }
}
```



## JWT 引入依赖

```xml
<!-- 引入JWT依赖-->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
</dependency>
```

JWT工具类

```java
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.util.StringUtils;

import javax.servlet.http.HttpServletRequest;
import java.util.Date;

/**
 * @author
 */
public class JwtUtils {

    public static final long EXPIRE = 1000 * 60 * 60 * 24;  //设置过期时间
    public static final String APP_SECRET = "ukc8BDbRigUDaY6pZFfWus2jZWLPHO"; //自定义密钥

    public static String getJwtToken(String id, String nickname){

        String JwtToken = Jwts.builder()
                .setHeaderParam("typ", "JWT")//设置头信息
                .setHeaderParam("alg", "HS256")
                .setSubject("guli-user")
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRE))//时间的校验
                .claim("id", id)//存入用户的ID
                .claim("nickname", nickname)//存入用户的用户名
                .signWith(SignatureAlgorithm.HS256, APP_SECRET) //将密钥放入进行加密
                .compact();

        return JwtToken;
    }

    /**
     * 判断token是否存在与有效
     * @param jwtToken
     * @return
     */
    public static boolean checkToken(String jwtToken) {
        if(StringUtils.isEmpty(jwtToken)) return false;
        try {
            Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    /**
     * 判断token是否存在与有效
     * @param request
     * @return
     */
    public static boolean checkToken(HttpServletRequest request) {
        try {
            String jwtToken = request.getHeader("token");
            if(StringUtils.isEmpty(jwtToken)) return false;
            Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    /**
     * 根据token获取会员id
     * @param request
     * @return
     */
    public static String getMemberIdByJwtToken(HttpServletRequest request) {
        String jwtToken = request.getHeader("token");
        if(StringUtils.isEmpty(jwtToken)) return "";
        Jws<Claims> claimsJws = Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);
        Claims claims = claimsJws.getBody();
        //获取jwt的主体信息 也就是有效载荷 更具key值取到相应的值 claims.get("name")
        return (String)claims.get("id");
    }
}
```

MD5加密工具类

```java
package com.edu.commonutils;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;


public final class MD5 {

    public static String encrypt(String strSrc) {
        try {
            char hexChars[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
                    '9', 'a', 'b', 'c', 'd', 'e', 'f' };
            byte[] bytes = strSrc.getBytes();
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(bytes);
            bytes = md.digest();
            int j = bytes.length;
            char[] chars = new char[j * 2];
            int k = 0;
            for (int i = 0; i < bytes.length; i++) {
                byte b = bytes[i];
                chars[k++] = hexChars[b >>> 4 & 0xf];
                chars[k++] = hexChars[b & 0xf];
            }
            return new String(chars);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            throw new RuntimeException("MD5加密出错！！+" + e);
        }
    }

    public static void main(String[] args) {
        System.out.println(MD5.encrypt("111111"));
    }

}
```

 前端vue携带token的值，这里前端使用    import cookie from 'js-cookie' 将token的存在token中

```java
<template>
  <div class="main">
    <div class="title">
      <a class="active" href="/login">登录</a>
      <span>·</span>
      <a href="/register">注册</a>
    </div>

    <div class="sign-up-container">
      <el-form ref="userForm" :model="user">

        <el-form-item class="input-prepend restyle" prop="email" :rules="[{ required: true, message: '请输入邮箱', trigger: 'blur' },{validator: checkPhone, trigger: 'blur'}]">
          <div >
            <el-input type="text" placeholder="邮箱号" v-model="user.email"/>
            <i class="iconfont icon-phone" />
          </div>
        </el-form-item>

        <el-form-item class="input-prepend" prop="password" :rules="[{ required: true, message: '请输入密码', trigger: 'blur' }]">
          <div>
            <el-input type="password" placeholder="密码" v-model="user.password"/>
            <i class="iconfont icon-password"/>
          </div>
        </el-form-item>

        <div class="btn">
          <input type="button" class="sign-in-button" value="登录" @click="submitLogin()">
        </div>
      </el-form>
      <!-- 更多登录方式 -->
      <div class="more-sign">
        <h6>社交帐号登录</h6>
        <ul>
          <li><a id="weixin" class="weixin" target="_blank" href="http://qy.free.idcfengye.com/api/ucenter/weixinLogin/login"><i class="iconfont icon-weixin"/></a></li>
          <li><a id="qq" class="qq" target="_blank" href="#"><i class="iconfont icon-qq"/></a></li>
        </ul>
      </div>
    </div>

  </div>
</template>

<script>
  import '~/assets/css/sign.css'
  import '~/assets/css/iconfont.css'
  import cookie from 'js-cookie'
  import loginApi from '@/api/login'
  export default {
    layout: 'sign',

    data () {
      return {
        user:{
          email:'',
          password:''
        },
        loginInfo:{}
      }
    },

    methods: {

submitLogin(){
            loginApi.submitLogin(this.user).then(response => {
              if(response.data.success){
                //把token存在cookie中、也可以放在localStorage中
                cookie.set('token', response.data.data.token, { domain: 'localhost' })
                //登录成功根据token获取用户信息
                loginApi.getLoginInfo().then(response => {
                  console.log(response.data.data)
                  this.loginInfo = response.data.data.userInfo
                  //将用户信息记录cookie
                  cookie.set('ucenter', this.loginInfo, { domain: 'localhost' })
                  //跳转页面
                  window.location.href = "/";
                })
              }
            })
      },
      checkPhone (rule, value, callback) {
        //debugger
        if (!(/^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/.test(value))) {
          return callback(new Error('邮箱的格式不正确'))
        }
        return callback()
      }
    }
  }
</script>
<style>
   .el-form-item__error{
    z-index: 9999999;
  }
</style>
```

login.js

```js
import request from '@/utils/request'
const api_name=`/ucenterservice/ucenter-member/`
export default {

  //登录
  submitLogin(userInfo) {
    return request({
      url: `${api_name}/login`,
      method: 'post',
      data: userInfo
    })
  },
  //根据token获取用户信息
  getLoginInfo() {
    return request({
      url: `${api_name}/getLoginInfo`,
      method: 'get',
     // headers: {'token': cookie.get('token')}
    })
    //headers: {'token': cookie.get('token')} 
  }
}
```

注册

```html
<template>
  <div class="main">
    <div class="title">
      <a href="/login">登录</a>
      <span>·</span>
      <a class="active" href="/register">注册</a>
    </div>

    <div class="sign-up-container">
      <el-form ref="userForm" :model="params">

        <el-form-item class="input-prepend restyle" prop="nickname" :rules="[{ required: true, message: '请输入你的昵称', trigger: 'blur' }]">
          <div>
            <el-input type="text" placeholder="你的昵称" v-model="params.nickname"/>
            <i class="iconfont icon-user"/>
          </div>
        </el-form-item>

        <el-form-item class="input-prepend restyle no-radius" prop="email" :rules="[{ required: true, message: '请输入邮箱', trigger: 'blur' },{validator: checkPhone, trigger: 'blur'}]">
          <div>
            <el-input type="text" placeholder="邮箱" v-model="params.email"/>
            <i class="iconfont icon-phone"/>
          </div>
        </el-form-item>

        <el-form-item class="input-prepend restyle no-radius" prop="code" :rules="[{ required: true, message: '请输入验证码', trigger: 'blur' }]">
          <div style="width: 100%;display: block;float: left;position: relative">
            <el-input type="text" placeholder="验证码" v-model="params.code"/>
            <i class="iconfont icon-phone"/>
          </div>
          <div class="btn" style="position:absolute;right: 0;top: 6px;width: 40%;">
            <a href="javascript:" type="button" @click="getCodeFun()" :value="codeTest" style="border: none;background-color: none">{{codeTest}}</a>
          </div>
        </el-form-item>

        <el-form-item class="input-prepend" prop="password" :rules="[{ required: true, message: '请输入密码', trigger: 'blur' }]">
          <div>
            <el-input type="password" placeholder="设置密码" v-model="params.password"/>
            <i class="iconfont icon-password"/>
          </div>
        </el-form-item>

        <div class="btn">
          <input type="button" class="sign-up-button" value="注册" @click="submitRegister()">
        </div>
        <p class="sign-up-msg">
          点击 “注册” 即表示您同意并愿意遵守简书
          <br>
          <a target="_blank" href="http://www.jianshu.com/p/c44d171298ce">用户协议</a>
          和
          <a target="_blank" href="http://www.jianshu.com/p/2ov8x3">隐私政策</a> 。
        </p>
      </el-form>
      <!-- 更多注册方式 -->
      <div class="more-sign">
        <h6>社交帐号直接注册</h6>
        <ul>
          <li><a id="weixin" class="weixin" target="_blank" href="http://huaan.free.idcfengye.com/api/ucenter/wx/login"><i
            class="iconfont icon-weixin"/></a></li>
          <li><a id="qq" class="qq" target="_blank" href="#"><i class="iconfont icon-qq"/></a></li>
        </ul>
      </div>
    </div>
  </div>
</template>

<script>
  import '~/assets/css/sign.css'
  import '~/assets/css/iconfont.css'

  import registerApi from '@/api/register'

  export default {
    layout: 'sign',
    data() {
      return {
        params: {
          email: '',
          code: '',
          nickname: '',
          password: ''
        },
        sending: true,      //是否发送验证码
        second: 60,        //倒计时间
        codeTest: '获取验证码'
      }
    },
    methods: {
      getCodeFun() {
        //sending = false
        //his.sending原为true,请求成功，!this.sending == true，主要是防止有人把disabled属性去掉，多次点击；
        if (!this.sending)
          return;

        //debugger
        // prop 换成你想监听的prop字段
        this.$refs.userForm.validateField('mail_code', (errMsg) => {
          if (errMsg == '') {
            registerApi.getMailCode(this.params.email).then(res => {
              this.sending = false;
              this.timeDown();
            });
          }
        })
      },
      //倒计时   发送验证码后倒计时
      timeDown() {
        let result = setInterval(() => {
          --this.second;
          this.codeTest = this.second
          if (this.second < 1) {
            clearInterval(result);
            this.sending = true;
            //this.disabled = false;
            this.second = 60;
            this.codeTest = "获取验证码"
          }
        }, 1000);

      },
      submitRegister() {
        this.$refs['userForm'].validate((valid) => {
          if (valid) {
            registerApi.submitRegister(this.params).then(response => {
              //提示注册成功
              this.$message({
                type: 'success',
                message: "注册成功"
              })
              this.$router.push({path: '/login'})
            })
          }
        })
      },

      checkPhone (rule, value, callback) {
        //debugger
        if (!(/^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/.test(value))) {
          return callback(new Error('邮箱格式不正确'))
        }
        return callback()
      }
    }
  }
</script>

```

register.js

```js
import request from '@/utils/request'

export default {
  //根据手机号码发送短信
  getMailCode(mobile) {
    return request({
      url: `/mailservice/send_email/${mobile}`,
      method: 'get'
    })
  },
  //用户注册
  submitRegister(formItem) {
    return request({
      url: `/ucenterservice/ucenter-member/register`,
      method: 'post',
      data: formItem
    })
  }
}
```

request.js    这里使用request对所有的请求进行一个token的携带

```js
import axios from 'axios'
import { MessageBox, Message } from 'element-ui'
import cookie from 'js-cookie'

// 创建axios实例
const service = axios.create({
  baseURL: 'http://localhost:9001',
  timeout: 15000 // 请求超时时间
  
})

// http request 拦截器
service.interceptors.request.use(
  config => {
  //debugger
  if (cookie.get('token')) {
    config.headers['token'] = cookie.get('token');
  }
    return config
  },
  err => {
  return Promise.reject(err);
})
// http response 拦截器
service.interceptors.response.use(
  response => {
    //debugger
    if (response.data.code == 28004) {
        console.log("response.data.resultCode是28004")
        // 返回 错误代码-1 清除ticket信息并跳转到登录页面
        //debugger
        window.location.href="/login"
        return
    }else{
        return response;
      
    }
  },
  error => {
    return Promise.reject(error.response)   // 返回接口返回的错误信息
});

export default service
```



## Vue表单active

```jsx
<el-menu :default-active="$route.path"
    class="el-menu-demo"
    mode="horizontal"
    router="router"
    text-color="#fff"
    background-color="#282b33"
    active-text-color="#ffd04b">
    <el-menu-item index="/index">菜单一</el-menu-item>
    <el-menu-item index="/index" disabled>菜单二</el-menu-item>
    <el-menu-item index="/index">菜单三</el-menu-item>
</el-menu>
```